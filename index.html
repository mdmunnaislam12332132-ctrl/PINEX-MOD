<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PINEX ULTIMATE | AI MOD</title>
    <style>
        /* BASIC DARK THEME */
        * { -webkit-tap-highlight-color: transparent; user-select: none; outline: none; box-sizing: border-box; }
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        #game-frame { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; z-index: 1; }
        .draggable { position: absolute; z-index: 10000; touch-action: none; cursor: move; }

        /* SKULL BUTTON */
        #main-skull {
            top: 100px; left: 20px; width: 50px; height: 50px;
            background: rgba(0,0,0,0.8); border: 2px solid #0f0; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 15px #0f0; cursor: pointer; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 10px #0f0; } 50% { box-shadow: 0 0 25px #0f0; } 100% { box-shadow: 0 0 10px #0f0; } }

        /* SIGNAL WIDGET */
        #signal-widget {
            top: 150px; right: 20px; width: 240px; height: 380px;
            background: rgba(0, 15, 0, 0.95); border: 2px solid #00ffff;
            border-radius: 12px; padding: 0; text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2); color: white;
            position: absolute; overflow: hidden; backdrop-filter: blur(5px);
            display: block;
        }
        
        .header { padding: 8px; background: rgba(0, 255, 255, 0.1); border-bottom: 1px solid #00ffff; font-size: 14px; font-weight: bold; color: #00ffff; letter-spacing: 2px; }

        /* ACTIVE SCAN BOX (TOP CORNER) */
        .scan-box {
            position: absolute; top: 35px; right: 5px; 
            padding: 2px 6px; border: 1px solid #ff00de; 
            font-size: 9px; color: #ff00de; background: #000; border-radius: 3px;
        }
        
        .pred-area { height: 100px; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; margin-top: 10px; }
        .big-txt { font-size: 55px; font-weight: 900; color: #ffff00; text-shadow: 0 0 20px #ffff00; }
        .small-txt { font-size: 55px; font-weight: 900; color: #00ffff; text-shadow: 0 0 20px #00ffff; }
        .skip-txt { font-size: 40px; font-weight: bold; color: #ff0000; animation: blink 0.5s infinite; }
        
        .wait-txt { font-size: 18px; color: #aaa; font-weight: bold; animation: blink 1s infinite; }

        /* WIN/LOSS STREAK DISPLAY */
        .streak-area {
            font-size: 16px; font-weight: bold; margin: 5px 0; padding: 5px;
            border-top: 1px solid #333; border-bottom: 1px solid #333;
        }
        .win-streak { color: #0f0; text-shadow: 0 0 10px #0f0; }
        .loss-streak { color: #f00; text-shadow: 0 0 10px #f00; }
        .super-win { color: #fff; text-shadow: 0 0 10px #fff, 0 0 20px #ff00de; animation: flash 0.3s infinite; }

        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; padding: 10px; }
        .info-box { background: #111; padding: 5px; border: 1px solid #333; border-radius: 4px; }
        .lbl { font-size: 10px; color: #888; display: block; }
        .val { font-size: 13px; font-weight: bold; color: #fff; }

        @keyframes blink { 50% { opacity: 0.5; } }
        @keyframes flash { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }

        /* TOAST NOTIFICATION */
        #toast { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: #333; color: #fff; padding: 8px 15px; border-radius: 20px; font-size: 12px; display: none; z-index: 20000; border: 1px solid #fff; }
    </style>
</head>
<body>

    <iframe src="https://tkclub2.com" id="game-frame"></iframe>

    <div id="main-skull" class="draggable" onclick="toggleUI()">ðŸ’€</div>

    <div id="signal-widget" class="draggable">
        <div class="header">PINEX DB SCANNER</div>
        
        <div id="pattern-trace" class="scan-box">SCANNING: ...</div>

        <div class="pred-area">
            <div id="result-display" class="wait-txt">WAITING...</div>
        </div>

        <div class="streak-area">
            STATUS: <span id="streak-val" style="color:#888">READY</span>
        </div>

        <div class="info-grid">
            <div class="info-box">
                <span class="lbl">NEXT PERIOD</span>
                <span class="val" id="period-val">---</span>
            </div>
            <div class="info-box">
                <span class="lbl">DB MATCHES</span>
                <span class="val" id="match-val" style="color:#ff00de">0</span>
            </div>
            <div class="info-box">
                <span class="lbl">CONFIDENCE</span>
                <span class="val" id="conf-val">0%</span>
            </div>
            <div class="info-box">
                <span class="lbl">LAST RESULT</span>
                <span class="val" id="last-res">---</span>
            </div>
        </div>

        <div style="font-size: 10px; color: #555; margin-top: 10px;">FIREBASE: <span style="color:#0f0">CONNECTED</span></div>
    </div>

    <div id="toast">Connecting...</div>

    <script>
        // CONFIG
        const DB_URL = "https://ck-win-36ca8-default-rtdb.firebaseio.com/wingo_records.json";
        
        // INTERNAL STATE
        let lastPeriod = null;
        let prediction = null;
        let streak = 0; // +ve for Win, -ve for Loss
        let isSkipping = false;

        async function mainLoop() {
            try {
                // 1. Fetch Data from Firebase
                let res = await fetch(DB_URL);
                let data = await res.json();
                if (!data) return;

                // 2. Sort Data by Period
                let keys = Object.keys(data).sort();
                let latestKey = keys[keys.length - 1];
                let latestData = data[latestKey];
                let currentPeriod = latestData.period;

                // 3. Check for New Period
                if (currentPeriod !== lastPeriod) {
                    
                    // A. Check Previous Result (Win/Loss Logic)
                    if (lastPeriod && prediction && prediction !== "SKIP") {
                        let actual = latestData.size; // BIG or SMALL
                        checkWinLoss(actual);
                    } else if (lastPeriod && prediction === "SKIP") {
                        showToast("Last Round: SKIPPED (No Bet)");
                    }

                    lastPeriod = currentPeriod;
                    let nextPeriod = (BigInt(currentPeriod) + 1n).toString();
                    document.getElementById('period-val').innerText = nextPeriod.slice(-4);
                    document.getElementById('last-res').innerText = latestData.size;

                    // B. Start Analysis Animation
                    document.getElementById('result-display').className = "wait-txt";
                    document.getElementById('result-display').innerText = "SCANNING DB...";
                    document.getElementById('pattern-trace').innerText = "FETCHING...";
                    
                    await new Promise(r => setTimeout(r, 2000)); // 2 sec fake delay

                    // C. Run Prediction Algorithm
                    let analysis = analyzePattern(data, keys);
                    
                    // D. Apply Skip Logic based on Loss Streak
                    if (streak <= -3) {
                        // If 3 losses, we need High Confidence (Matches > 7) to bet
                        if (analysis.matches < 8) {
                            prediction = "SKIP";
                            analysis.conf = 0;
                        } else {
                            prediction = analysis.pred;
                        }
                    } else {
                        prediction = analysis.pred;
                    }

                    // E. Display Result
                    displayPrediction(prediction, analysis);

                }

            } catch (e) { console.error("Sync Error", e); }
        }

        function analyzePattern(data, keys) {
            // Get last 5 results from DB for pattern matching
            let history = keys.map(k => data[k].size); // ["BIG", "SMALL", ...]
            let patternLen = 5;
            if (history.length < 10) return { pred: "SKIP", matches: 0, conf: 0 };

            let currentPattern = history.slice(-patternLen); // Last 5 items
            
            // Show scanning pattern in UI
            let shortPat = currentPattern.map(s => s[0]).join(""); // "BSBBS"
            document.getElementById('pattern-trace').innerText = `SCAN: ${shortPat}`;

            // Search History
            let bCount = 0; 
            let sCount = 0;
            let matches = 0;

            // Loop through history (excluding the very last current pattern)
            for (let i = 0; i < history.length - patternLen - 1; i++) {
                let slice = history.slice(i, i + patternLen);
                
                // If match found
                if (JSON.stringify(slice) === JSON.stringify(currentPattern)) {
                    matches++;
                    let nextVal = history[i + patternLen];
                    if (nextVal === "BIG") bCount++;
                    else if (nextVal === "SMALL") sCount++;
                }
            }

            // Logic
            let pred = "SKIP";
            let conf = 0;
            
            if (matches > 0) {
                if (bCount > sCount) {
                    pred = "BIG";
                    conf = Math.round((bCount / matches) * 100);
                } else if (sCount > bCount) {
                    pred = "SMALL";
                    conf = Math.round((sCount / matches) * 100);
                }
            } else {
                // No match, create reverse trend of last item
                let last = history[history.length - 1];
                pred = (last === "BIG") ? "SMALL" : "BIG";
                conf = 40; // Low confidence
            }

            return { pred, matches, conf };
        }

        function checkWinLoss(actual) {
            if (actual === prediction) {
                // WIN
                if (streak < 0) streak = 0; // Reset loss
                streak++;
                showToast(`âœ… WIN! Result was ${actual}`);
            } else {
                // LOSS
                if (streak > 0) streak = 0; // Reset win
                streak--;
                showToast(`âŒ LOSS! Result was ${actual}`);
            }
            updateStreakUI();
        }

        function updateStreakUI() {
            let el = document.getElementById('streak-val');
            if (streak > 3) {
                el.innerHTML = `SUPER WIN ðŸ”¥ x${streak}`;
                el.className = "super-win";
            } else if (streak > 0) {
                el.innerText = `WIN STREAK x${streak}`;
                el.className = "win-streak";
            } else if (streak < 0) {
                el.innerText = `LOSS STREAK ${streak}`;
                el.className = "loss-streak";
            } else {
                el.innerText = "NEUTRAL";
                el.className = "";
                el.style.color = "#888";
            }
        }

        function displayPrediction(pred, analysis) {
            let resEl = document.getElementById('result-display');
            
            if (pred === "BIG") {
                resEl.innerText = "BIG";
                resEl.className = "big-txt";
            } else if (pred === "SMALL") {
                resEl.innerText = "SMALL";
                resEl.className = "small-txt";
            } else {
                resEl.innerText = "SKIP âš ï¸";
                resEl.className = "skip-txt";
            }

            document.getElementById('match-val').innerText = analysis.matches;
            document.getElementById('conf-val').innerText = analysis.conf + "%";
        }

        // UTILS
        function showToast(msg) {
            let t = document.getElementById('toast');
            t.innerText = msg;
            t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 3000);
        }

        function toggleUI() {
            let w = document.getElementById('signal-widget');
            w.style.display = (w.style.display === 'none') ? 'block' : 'none';
        }

        // DRAG LOGIC
        document.querySelectorAll('.draggable').forEach(el => {
            let isDown = false, offX, offY;
            el.addEventListener('mousedown', e => { isDown=true; offX=e.clientX-el.offsetLeft; offY=e.clientY-el.offsetTop; });
            document.addEventListener('mousemove', e => { if(isDown) { el.style.left=(e.clientX-offX)+'px'; el.style.top=(e.clientY-offY)+'px'; }});
            document.addEventListener('mouseup', () => isDown=false);
            el.addEventListener('touchstart', e => { offX=e.touches[0].clientX-el.offsetLeft; offY=e.touches[0].clientY-el.offsetTop; }, {passive:true});
            el.addEventListener('touchmove', e => { e.preventDefault(); el.style.left=(e.touches[0].clientX-offX)+'px'; el.style.top=(e.touches[0].clientY-offY)+'px'; }, {passive:true});
        });

        // START
        setInterval(mainLoop, 3000);
        showToast("System Initialized");
    </script>
</body>
</html>
